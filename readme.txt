通过netty实现自定义协议物联网网关（附有报文格式）——单机版（已测试可用）

window笔记本电脑本地测试：单网关、单前置节点，每秒处理上行并发心跳4000+（并发下行未统计），20W在线终端内存占用量1G

终端心跳检测，终端超过300秒无应答，则网关主动关闭通道，并清理缓存

目前设置的网关与前置channel通讯的channel高低水位为，低水位32M，高水位64M。
new WriteBufferWaterMark(32 * 1024 * 1024, 64 * 1024 * 1024)
设置水位线的作用是：防止服务器处理能力极其低下但连接正常时，造成channel中缓存大量数据影响网关性能

***************************************************************************************************************************
1. 入口类:
	Server4Terminal.java
***************************************************************************************************************************
2. 项目结构及说明：

--------------------------------辅助包----------------------------
	@ base包(基本类)
		|-cache包 
		|		|
		|		 ClientChannelCache.java	用于存储大量终端与网关连接之后 建立的channel实例，在网关接收到前置			
		|								发送过来的的下行报文之后，需要通过终端ip获取channel并发送数据）
		|-chachequeue包
		|		|
		|		 CacheQueue.java类封装了其他一些ConcurrentHashMap,一些数据流转用的对列等
		|
		|-constant包
		|       |
		|        ConstantValue.java 常量类
		|
		|-domain包
				|
				|ChannelData.java 封装了ipAddress属性（每个终端建立连接时，获取终端的ip地址）组合了SocketData对象，
				|SocketData.java 封装了终端发送到网关的报文信息（我称之为“真实报文”）
				|GateHeader.java 封装了网关报头拼装的一些工具方法
	
	@ threadWorkers包(自定义线程)
			    |
			     TServer2MClient.java  实现了Runnable接口，用于从CacheQueue.up2MasterQueue队列中获取数据并发送到前置（具体实现 看代码）
	    
	@ util包(工具包)
	    		|
	    		|CommonUtil.java  通用工具类	
	    		 *StringUtils.java 用于 字节数组 与 String字符串之间的相关转化等

---------------------------------通信包------------------------------------
	    		 
	@ server包(服务端)
		|		|
	    |		 Server4Terminal.java “入口类” 网关获取终端连接请求的服务端
	    |
	    |-handler包
	    		|
	    		 SocketInHandler.java “入站控制器” 所有网关与终端连接创建的channel的pipeline中绑定该handler

	@ client包(客户端)
		|		|
		|		 Client2Master.java 网关请求连接到前置的客户端
		| 
		|-handler包
				|
				 Client2MasterInHandler.java “入站控制器” 绑定到Client2Master
				 
	@ codec包(编解码器)
				|
				|Gate2ClientDecoder.java 自定义网关到终端通讯 解码器  作用：byte[] ---> domain
				|Gate2ClientEncoder.java 自定义网关到终端通讯 编码器  作用：domain ---> byte[]
				|Gate2MasterDecoder.java 自定义网关到前置通讯 解码器  作用：1.去网关头(A8开头长度28个字节)2.byte[] ---> domain 
				 Gate2MasterEncoder.java 自定义网关到前置通讯 编码器  作用：1.加网关头(A8开头长度28个字节)2.domain ---> byte[]
				 
				 
--------------------------------辅助测试包---------------------------------

	@ test包(辅助测试)
		|		|
		|		|
		|		 CountHelper.java 定义了模拟终端、模拟前置需要一些基本的并发计数功能的变量
		|		
		|-moniMaster包		 
		|		|
		|		|moniMaster.java “入口类” 模拟前置服务端
		|		|moniMasterHandler.java 模拟前置服务端handler
		|		moniMasterDecoder.java 模拟前置的解码器*****
		|		
		|-moniTerminal包
				|moniTerminal.java “入口类” 模拟终端客户端--并发模拟--moniMasterHandler类中判断时间依据本类的并发量
				moniTerminalHandler.java 模拟终端handler

***************************************************************************************************************************
			 
 3. 自定义网关报头的结构与注意事项
 
 	*网关报头，是网关与前置通信时，作为网关登录和传输真实报文时携带网关自身和终端响应参数的报文，报文
 	*结构是自己定义，前置按照定义好的报文格式获取数据并做相应处理。
 
 	网关报头结构：
 		A8					---  1byte  报文头
 		len				    ---  2byte  长度域：真实报文长度，包含“68”，“16”
 		type				---  1byte  报头类型
 		protocolType		---  1byte  协议类型（左侧起第一个bit为0 表示IPV4, 1表示IPV6  剩余7个bit表示规约类型编号）
 		gateNum				---  1byte  网关编号
 		00*12				---  12byte 如果ip格式为IPV4，则当前为12字节0，反之，当前得12个byte+后续得4byte存放IPV6的值，存放顺序从左至右依次
 		clientIP			---  4byte  终端的IP地址，ip地址的每个段位占一个字节（不含符号和端口号）
 		port				---  2byte  终端对应的端口号
 		count				---  4byte  终端与网关建立连接时对应的连接序号（1-10000循环）
 		

	 * 组网关报头---网关向前置发送网关登录报文时与网关向前置发送真实报文时 报头区别：
	 * 1.登录时长度为0；有真实报文时，长度域为整个真实报文长度值
	 * 2.登录时type = 03；protocolType=15;count=1都为固定值；发送真实报文时，type=01,protocolType=00;count=终端与网关的连接序号
	 
---前置发现报头长度为0 且type = 03; protocolType=15;就不会执行解析数据的方法，否则会继续解析真实报文


***************************************************************************************************************************

4.真实报文结构与注意事项
	*“真实报文”即终端与网关通信使用的报文，规约不同可能结构会有所差异

	真实报文结构：
		68					---  1byte     报头
		len					---  2byte     长度域 "传输帧中除起始字符和结束字符之外的帧字节数"
		...					---  len byte  报文内容 
		16                  ---  1byte     报尾
		
		
	网关需要在解码器中做真实报文的“真实性”、“完整性”验证，只有验证通过的报文才会被网关接收
	
***************************************************************************************************************************
	